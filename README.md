目录

* [Refinition](https://github.com)
  + [四个核心角色](https://github.com)
  + [四类常见授权模式](https://github.com)
  + [授权模式中的术语](https://github.com)
* [OAuth2 协议流程解析](https://github.com):[悠兔机场加速器订阅](https://www.baijiatu.com)
* [后端之间的交互流程-包含安全方案设计](https://github.com)
  + [应用注册与安全凭证发放](https://github.com)
  + [OAuth2授权码流程](https://github.com)
  + [为什么用code不直接返回token?](https://github.com)

---

# Refinition

OAuth2 是在WEB基础上发展出来的一个授权框架（Authorization Framework），也可以认为它是一套协议，一套能解决第三方授权问题的解决方案，优势在于**它允许第三方应用在不获取用户密码的情况下，获得访问用户资源（用户的ID信息等）的有限权限。**

它是如何做到的？下面来解析一下这个协议。

搞懂这个协议，需要理解下面几个部分：

## 四个核心角色

OAuth2 流程中有四个关键角色：

* **资源所有者** (Resource Owner)
  用户（一般指使用客户端的人），他拥有受保护资源（一般指他的账号信息）；
* **客户端** (Client)
  一个前端UI应用，方便用户操作的面板。一般来说客户端和授权服务器是前后端关系。
* **授权服务器** (Authorization Server)
  验证用户身份并颁发令牌的 绝对控制者。
* **资源服务器** (Resource Server)
  一般指可以提供给用户使用的服务器，能给用户提供专属服务，比如网盘服务、点外卖服务，这种也叫第三方应用。
  资源服务器一般需要用户信息，才能提供服务。
  获得用户信息，可以让用户注册，但是APP太多了，很多用户不愿意注册了。就发展出第三方应用去授权服务器拿取用户ID的免注册模式。

## 四类常见授权模式

OAuth2 定义了多种授权方式，适应不同场景，下面看4个常见：

* **授权码模式** (Authorization Code) - 最常用、较安全（本文讨论这个模式）
* 密码模式 (Resource Owner Password Credentials) - 需要信任客户端
* 客户端凭证模式 (Client Credentials) - 应用访问自己的资源
* 隐式模式 (Implicit) - 较不安全，已不推荐

## 授权模式中的术语

* 令牌 (Tokens)

  + 访问令牌 (Access Token)：相当于"临时门禁卡"，用于访问资源
  + 刷新令牌 (Refresh Token)：用于获取新的访问令牌，避免用户频繁重新登录
* ......

---

# OAuth2 协议流程解析

在看时序图之前，必须先清楚各个角色的作用，不然就会混乱。

时序图，简版流程：

资源服务器授权服务器客户端应用资源服务器授权服务器客户端应用1. 启动授权流程2. 用户认证与授权3. 交换令牌（后端通信）4. 访问资源用户访问应用重定向到授权服务器在授权页面登录并授权重定向回应用并携带授权码发送授权码 + 客户端凭证返回访问令牌使用访问令牌请求资源返回受保护资源显示用户请求的内容用户

---

更接近实际的流程，以企微授权一个工作台应用案例为例子：

企业微信资源服务器企业微信授权服务器企微工作台应用(Your Server)企业微信客户端(浏览器/WebView)企业微信资源服务器企业微信授权服务器企微工作台应用(Your Server)企业微信客户端(浏览器/WebView)认证与授权阶段获取访问令牌与用户信息正常业务访问用户1. 点击工作台应用图标2. 访问应用首页 (GET /)3. 重定向到企微授权页?response\_type=code&redirect\_uri=...4. 跳转到授权页面5. (可选) 向用户显示授权同意页面6. 点击同意授权7. 重定向到 redirect\_uri 并携带 code8. 请求 Callback URL (GET /callback?code=...)9. 用 code 换取 access\_token(POST /token) + secret10. 返回 access\_token11. 使用 access\_token 获取用户信息(GET /userinfo?access\_token=...)12. 返回用户信息 (e.g., UserId)13. 根据UserId处理业务逻辑(e.g., 查询数据库)14. 返回个性化应用页面15. 显示应用内容用户

以上都是以一个用户视角看的流程，其实后端之间还做了很多事情，才能保障整个流程的安全，不过下面的流程图需要以一个开发者的角度看待，下面继续解构。

---

# 后端之间的交互流程-包含安全方案设计

下面以企业微信OAuth2授权码流程，以开发者（应用服务器/资源服务器）的视角，看待应用如何与企微授权服务器建立联系，包括如何获取安全凭证（如Secret）、验证的流程。

企业微信OAuth2授权码流程中，开发者需要先在企微管理后台创建应用，获取应用的安全凭证（corp\_id, secret等），然后在应用服务器中使用这些凭证。

整体流程分为两个主要部分：

* 应用注册与安全凭证发放（静态配置）
* OAuth2授权码流程（动态交互）

理解几个密码学上关键的工具包：

* AgentId
* Secret
* 随机数
* 签名-HMAC
* ......

---

## 应用注册与安全凭证发放

这一步是确保整体安全的关键流程，Secret参数作为一个关键密钥（可以申请更换），它也是标识身份，防抵赖性作用。
一个AgentId 对应 一把Secret密钥。
**Secret必须安全地存储在应用服务器内，只做打签名用。不可以暴露，否则有被冒充安全风险！**

应用服务器企微管理后台开发者应用服务器企微管理后台开发者1. 登录管理后台2. 创建应用（设置应用名称、logo等）3. 返回应用凭证：AgentId、Secret等4. 配置AgentId和Secret

---

## OAuth2授权码流程

**State：**
客户端**生成 State** 流程：

1. 收集数据：随机数 + 时间戳 + 会话ID + 业务参数
2. 构建结构：
3. 计算签名：HMAC-SHA256(排序后的数据字符串, client\_secret)
4. 添加签名：
5. Base64编码：生成最终的state参数

客户端/服务端**验证 State** 流程：

1. Base64解码state，得到原始数据结构
2. 提取签名值，从数据结构中移除签名字段
3. 重新计算签名：HMAC-SHA256(相同的排序数据, client\_secret)
4. 对比签名：恒定时间比较计算签名与提取签名
5. 如果一致 → 数据未被篡改，验证通过
6. 如果不一致 → 可能被篡改，拒绝请求

客户端生成state

使用client\_secret签名

客户端验证state

使用client\_secret验签

确保数据完整性

---

**再次看OAuth2授权码流程**：

流程图是AI生成的，有些角色关系描述得不是那么准确，但是大致理解state、code的安全流程是没问题的。请辩证的看。

令牌存储授权服务器浏览器客户端应用用户令牌存储授权服务器浏览器客户端应用用户State 生成与签名阶段- 收集会话ID- 生成随机数- 记录时间戳- 添加业务上下文- 排序数据字段- 计算HMAC签名- Base64编码用户认证与授权阶段Code 生成阶段- 关联用户ID- 绑定客户端ID- 设置权限范围- 添加时间戳- code值- 用户信息- 客户端信息- 过期时间State 校验与 Code 验证阶段- Base64解码- 验证签名- 检查时效性- 会话匹配1. 访问应用2. 生成 State 参数3. State 签名4. 存储State到Session5. 重定向到授权页(带state)6. 请求授权页面7. 显示登录页面8. 输入凭证并授权9. 验证用户凭证10. 生成授权码(Code)11. 存储Code元数据12. 重定向回客户端(带code+state)13. 请求回调URL14. 提取并验证State15. 清理已用State16. 用Code交换Token17. 验证Code有效性18. 返回Code关联信息19. Code使用标记20. 返回访问令牌21. 清理已用Code22. 完成授权流程

---

## 为什么用code不直接返回token?

授权码（code）的安全作用介绍：

授权码（code）是OAuth2授权码流程中的核心凭证，它通过前端信道传递（浏览器重定向），然后由客户端应用在后端信道中与授权服务器交换访问令牌。授权码的安全作用主要包括：

* 避免访问令牌通过前端信道传输，降低令牌泄露风险。
* 授权码是短暂的，一次性使用的，降低被窃取后的风险。
* 授权码与客户端身份绑定，防止被其他客户端使用。

假设code被截取：

* 即使授权码被窃取，攻击窗口很短
* 自动清理过期的授权码，减少存储负担

所以code也不能保证绝对安全，但是相对安全，防CSRF类攻击时，它是有效的。
